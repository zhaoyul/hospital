#+title: Reagent 与 Ant Design 在项目中的应用总结

本文档总结了项目中 Reagent 和 Ant Design 的使用方式，重点关注组件渲染、表单管理以及使用 re-frame 进行状态管理。

* 组件渲染：`:>` 和 `:f>`

项目使用 Reagent 的 Hiccup 风格语法来定义 UI 组件。

- **`:>` (渲染 Ant Design 组件 / HTML 元素):** 此语法主要用于渲染 Ant Design 组件。Ant Design 组件从 "antd" 库导入。它同时也是渲染常规 HTML DOM 元素的标准 Hiccup 语法。

  *示例来源 `src/cljs/hc/hospital/components/form_components.cljs` (Ant Design 按钮):*
  #+begin_src clojure
  [:> Button {:type "primary"} "提交"] ;; 渲染一个 Ant Design 的按钮组件
  #+end_src

  *示例来源 `src/cljs/hc/hospital/pages/questionnaire.cljs` (Ant Design 表格):*
  #+begin_src clojure
  [:> Table {:columns questionnaire-columns ;; 表格列的定义
             :dataSource mock-questionnaire-data}] ;; 表格数据源
  #+end_src

- **`:f>` (渲染 Reagent Form-2/Form-3 组件):** 此语法用于渲染定义为 "Form-2" 或 "Form-3" 的 Reagent 组件（即返回渲染函数的函数，或接受参数并返回渲染函数的函数）。这通常用于顶层组件，或者那些通过 `r/atom` 管理自身状态或需要生命周期方法的组件。

  *示例来源 `src/cljs/hc/hospital/core.cljs` (根 Reagent 组件):*
  #+begin_src clojure
  (d/render [:f> app-root] (.getElementById js/document "app")) ;; 使用 :f> 渲染 app-root 根组件
  #+end_src
  虽然项目中的许多组件被定义为简单函数 (Form-1 组件) 并使用标准的 `[:> component-fn]` 或 `[component-fn]` 语法渲染，但 `:f>` 适用于那些需要 Reagent Form-2/3 组件提供的更复杂生命周期或状态管理功能的组件。通常，如果简单 Reagent 组件是返回 Hiccup 的简单函数，它们也可能用 `:>` 来调用。

* 使用 Ant Design 管理表单

Ant Design 的 Form 组件 (`antd/Form`) 是创建和管理表单的主要工具。

- **`Form.useForm`:** 这个钩子用于创建一个表单实例，该实例提供控制表单的方法，例如获取或设置字段值、校验字段和重置表单。

  *示例来源 `src/cljs/hc/hospital/components/form_components.cljs` (`standard-form` 组件内部):*
  #+begin_src clojure
  (defn standard-form [{:keys [form-data subscription-key update-event form-content]}]
    (let [data @(rf/subscribe [subscription-key]) ;; 从 re-frame 订阅获取表单初始值
          [form] ((.-useForm (.-Form js/antd)))] ; <--- 调用 Form.useForm 钩子获取表单实例
      [:> Form {:form form ;; 将表单实例传递给 Form 组件
                :layout "vertical" ;; 设置布局为垂直
                :initialValues data ;; 设置表单初始值
                :onValuesChange (fn [_changed-values all-values] ;; 表单值改变时的回调
                                  (rf/dispatch [update-event all-values])) ;; 派发 re-frame 事件更新状态
                :style {:paddingBottom "24px"}}
       form-content])) ;; 渲染表单内容
  #+end_src
  这里，`((.-useForm (.-Form js/antd)))` 调用了 `useForm` 钩子，`form` 成为了表单实例。然后这个实例被传递给 Ant Design `Form` 组件的 `:form` 属性。

- **响应表单变化 (`:onValuesChange` 和 `Form.useWatch`):**
  - **`:onValuesChange`**: 本项目主要使用 `Form` 组件的 `:onValuesChange` 属性来响应任何表单字段的变化。当一个值改变时，`:onValuesChange` 回调被触发，然后派发一个 re-frame 事件来更新应用状态。

    *示例来源 `src/cljs/hc/hospital/components/form_components.cljs` (`standard-form` 组件内部):*
    #+begin_src clojure
    [:> Form {;; ... 其他属性
              :onValuesChange (fn [_changed-values all-values] ;; 当表单内任意字段值改变时
                                (rf/dispatch [update-event all-values])) ;; 派发事件，携带所有值
              ;; ...
              }]
    #+end_src
    这种方法将表单状态管理集中在 re-frame 的 app DB 中，而不是通过 `Form.useWatch` 使用组件局部状态。

  - **`Form.useWatch`**: 虽然本项目未使用 `Form.useWatch`，但它可以用于在组件内部观察特定字段的变化，而无需立即更新全局状态。例如，可以直接在组件的渲染逻辑中根据一个字段的值有条件地禁用另一个字段。

  - **`:dependencies`**: 在 `checkbox-with-conditional-input` 组件中，使用了 `:dependencies` 属性来声明字段间的依赖关系，这与 `Form.useWatch` 的目的一些情况下是类似的，用于根据依赖字段的值动态改变当前字段的行为或外观。

    *示例来源 `src/cljs/hc/hospital/components/form_components.cljs` (部分相关代码):*
    #+begin_src clojure
    [:> Form.Item {:name field-name
                   :noStyle true
                   :dependencies [(keyword (str field-name "-checkbox"))]} ;; 声明依赖于同名前缀的 checkbox
     ;; fixme (原注释，表示此部分待修复或实现)
     #_(fn [form-instance] ;; 这是一个函数作为子元素，用于动态渲染
         (let [checked? (.getFieldValue form-instance (keyword (str field-name "-checkbox")))] ;; 获取依赖 checkbox 的值
           [:> Input {:placeholder "请输入"
                      :disabled (not checked?) ;; 根据 checkbox 是否选中来禁用输入框
                      :style {:width (or input-width "100%")}}]))]
    #+end_src
    这段被注释掉的代码展示了如何使用表单实例 (`form-instance`) 来获取一个字段的值，并动态地改变 UI。在更复杂的场景下，`Form.useWatch` 可以作为这种模式的替代方案。

* 使用 re-frame 进行状态管理

`re-frame` 用于管理应用程序的状态。

- **App DB (应用数据库):** 应用程序的状态存储在一个单一的、全局的 atom 中，称为 "app DB"。这个数据库的初始结构在 `src/cljs/hc/hospital/db.cljs` 中定义。

  *示例来源 `src/cljs/hc/hospital/db.cljs` (`default-db`):*
  #+begin_src clojure
  (def default-db
    { ;; 整个默认数据库状态的根 Map
     :anesthesia ;; 麻醉模块状态
     {:active-tab "patients" ;; 当前选中的主标签页
      :all-patient-assessments [] ;; 所有患者评估列表
      :current-patient-id nil ;; 当前选中的患者ID
      ;; ... 更多麻醉相关状态
      }
     :doctors [] ;; 医生列表
     :current-doctor nil ;; 当前登录的医生信息
     :is-logged-in false ;; 是否已登录
     ;; ... 更多全局状态
     })
  #+end_src

- **Events (事件):** 事件是描述应用中发生的事情的消息（例如，用户交互、服务器响应）。事件被派发 (dispatch) 以更新 app DB。事件处理器使用 `rf/reg-event-db` (用于对 app DB 的同步更改) 或 `rf/reg-event-fx` (用于带有副作用的事件，如 HTTP 请求) 来注册。

  *派发事件 (来源 `src/cljs/hc/hospital/components/form_components.cljs`):*
  #+begin_src clojure
  (rf/dispatch [update-event all-values]) ;; 派发事件，事件类型为 update-event，参数为 all-values
  #+end_src

  *注册事件处理器 (来源 `src/cljs/hc/hospital/events.cljs`):*
  #+begin_src clojure
  ;;注册一个处理数据库更新的事件
  (rf/reg-event-db ::update-canonical-assessment-field
    (fn [db [_ path value]] ;; db 是当前的 app DB，[_ path value] 是事件向量解构
      (assoc-in db (concat [:anesthesia :current-assessment-canonical] path) value))) ;; 更新 db 中指定路径的值

  ;; 注册一个处理副作用（HTTP请求）的事件
  (rf/reg-event-fx ::fetch-all-assessments
    (fn [_ _] ;; 不需要 app DB 或事件参数
      {:http-xhrio {:method          :get ;; HTTP GET 请求
                    :uri             "/api/patient/assessments" ;; 请求地址
                    :response-format (ajax/json-response-format {:keywords? true}) ;; 期望 JSON 响应并转为关键字
                    :on-success      [::set-all-assessments] ;; 成功时派发的事件
                    :on-failure      [::fetch-all-assessments-failed]}})) ;; 失败时派发的事件
  #+end_src

- **Subscriptions (订阅):** 订阅提供了一种从 app DB 响应式地访问数据的方式。组件订阅 app DB 的特定部分，当订阅的数据发生变化时，re-frame 会确保这些组件重新渲染。订阅使用 `rf/reg-sub` 注册。

  *在组件中订阅数据 (来源 `src/cljs/hc/hospital/core.cljs`):*
  #+begin_src clojure
  (let [session-check-pending? @(rf/subscribe [::subs/session-check-pending?]) ;; 订阅会话检查是否挂起的状态
        is-logged-in? @(rf/subscribe [::subs/is-logged-in])] ;; 订阅用户是否已登录的状态
    ;; ... 使用订阅到的值
  )
  #+end_src

  *注册订阅 (来源 `src/cljs/hc/hospital/subs.cljs`):*
  #+begin_src clojure
  ;; 注册一个简单的订阅，直接从 db 中获取数据
  (rf/reg-sub ::current-canonical-assessment
    (fn [db _] ;; db 是 app DB，第二个参数是查询向量（此处未使用）
      (get-in db [:anesthesia :current-assessment-canonical]))) ;; 返回当前规范化评估数据

  ;; 注册一个带有输入信号（其他订阅）的计算订阅
  (rf/reg-sub ::filtered-patients
    :<- [::all-patient-assessments] ;; 输入信号1：所有患者评估
    :<- [::search-term] ;; 输入信号2：搜索词
    ;; ... 其他可能的输入信号
    (fn [[api-assessments search-term] _] ;; 解构输入信号的值
      ;; ... 根据输入信号计算并返回派生数据（过滤后的患者列表）
      ))
  #+end_src

Reagent 用于组件定义，Ant Design 用于 UI 小部件和表单处理，re-frame 用于状态管理，这种组合为构建应用程序的前端提供了一种结构化的方法。
