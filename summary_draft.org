#+title: Reagent and Ant Design Usage Summary

This document summarizes how Reagent and Ant Design are utilized within the project, focusing on component rendering, form management, and state management with re-frame.

* Component Rendering: `:>` and `:f>`

The project uses Reagent's Hiccup-style syntax for defining UI components.

- **`:>` (Render Ant Design Component / HTML element):** This syntax is predominantly used to render Ant Design components. Ant Design components are imported from the "antd" library. It's also the standard Hiccup syntax for rendering regular HTML DOM elements.

  *Example from `src/cljs/hc/hospital/components/form_components.cljs` (Ant Design Button):*
  #+begin_src clojure
  [:> Button {:type "primary"} "Submit"]
  #+end_src

  *Example from `src/cljs/hc/hospital/pages/questionnaire.cljs` (Ant Design Table):*
  #+begin_src clojure
  [:> Table {:columns questionnaire-columns
             :dataSource mock-questionnaire-data}]
  #+end_src

- **`:f>` (Render Reagent Form-2/Form-3 Component):** This syntax is used to render Reagent components that are defined as "Form-2" or "Form-3" components (functions that return a render function, or functions that take arguments and return a render function). This is typically used for top-level components or components that manage their own state via `r/atom` or need lifecycle methods.

  *Example from `src/cljs/hc/hospital/core.cljs` (Root Reagent component):*
  #+begin_src clojure
  (d/render [:f> app-root] (.getElementById js/document "app"))
  #+end_src
  While many components in the project are defined as simple functions (Form-1 components) and rendered using the standard `[:> component-fn]` or `[component-fn]` syntax, `:f>` is available for components requiring more complex lifecycle or state management features provided by Reagent's Form-2/3 components. Often, simple Reagent components are also called with `:>` if they are simple functions returning Hiccup.

* Form Management with Ant Design

Ant Design's Form component (`antd/Form`) is the primary tool for creating and managing forms.

- **`Form.useForm`:** This hook is used to create a form instance, which provides methods for controlling the form, such as getting or setting field values, validating fields, and resetting the form.

  *Example from `src/cljs/hc/hospital/components/form_components.cljs` (within `standard-form`):*
  #+begin_src clojure
  (defn standard-form [{:keys [form-data subscription-key update-event form-content]}]
    (let [data @(rf/subscribe [subscription-key])
          [form] ((.-useForm (.-Form js/antd)))] ; <--- Form.useForm hook
      [:> Form {:form form
                :layout "vertical"
                :initialValues data
                :onValuesChange (fn [_changed-values all-values]
                                  (rf/dispatch [update-event all-values]))
                :style {:paddingBottom "24px"}}
       form-content]))
  #+end_src
  Here, `((.-useForm (.-Form js/antd)))` invokes the `useForm` hook, and `form` becomes the form instance. This instance is then passed to the `:form` prop of the Ant Design `Form` component.

- **Reacting to Form Changes (`:onValuesChange` as an alternative to `Form.useWatch`):**
  While `Form.useWatch` is a specific Ant Design hook to watch for changes in a particular field, this codebase primarily uses the `:onValuesChange` prop of the `Form` component to react to changes in any form field. When a value changes, the `:onValuesChange` callback is triggered, which then dispatches a re-frame event to update the application state.

  *Example from `src/cljs/hc/hospital/components/form_components.cljs` (within `standard-form`):*
  #+begin_src clojure
  [:> Form {;; ... other props
            :onValuesChange (fn [_changed-values all-values]
                              (rf/dispatch [update-event all-values]))
            ;; ...
            }]
  #+end_src
  This approach centralizes form state management within the re-frame app DB rather than using component-local state via `Form.useWatch`. If fine-grained watching of specific fields within a component (without necessarily updating global state immediately) were required, `Form.useWatch` could be employed. For example, to conditionally disable a field based on another field's value directly within the component's rendering logic.

  A more direct use of field dependencies can be seen in `checkbox-with-conditional-input` where `:dependencies` is used, though the function body for dynamic rendering was commented out:
  #+begin_src clojure
  [:> Form.Item {:name field-name
                 :noStyle true
                 :dependencies [(keyword (str field-name "-checkbox"))]}
   ;; fixme
   #_(fn [form-instance]
       (let [checked? (.getFieldValue form-instance (keyword (str field-name "-checkbox")))]
         [:> Input {:placeholder "请输入"
                    :disabled (not checked?)
                    :style {:width (or input-width "100%")}}]))]
  #+end_src
  This commented-out code shows how one might use the form instance to get a field value and dynamically alter the UI, a pattern where `Form.useWatch` would be an alternative for more complex scenarios.

* State Management with re-frame

`re-frame` is used for managing the application's state.

- **App DB:** The application state is stored in a single, global atom called the "app DB". The initial structure of this database is defined in `src/cljs/hc/hospital/db.cljs`.

  *Example from `src/cljs/hc/hospital/db.cljs` (`default-db`):*
  #+begin_src clojure
  (def default-db
    { ;; Root map for the entire default database state
     :anesthesia
     {:active-tab "patients"
      :all-patient-assessments []
      :current-patient-id nil
      ;; ... more anesthesia state
      }
     :doctors []
     :current-doctor nil
     :is-logged-in false
     ;; ... more global state
     })
  #+end_src

- **Events:** Events are messages that describe something that has happened in the application (e.g., user interaction, server response). Events are dispatched to update the app DB. Event handlers are registered using `rf/reg-event-db` (for synchronous changes to app DB) or `rf/reg-event-fx` (for events with side effects like HTTP requests).

  *Dispatching an event (from `src/cljs/hc/hospital/components/form_components.cljs`):*
  #+begin_src clojure
  (rf/dispatch [update-event all-values])
  #+end_src

  *Registering an event handler (from `src/cljs/hc/hospital/events.cljs`):*
  #+begin_src clojure
  (rf/reg-event-db ::update-canonical-assessment-field
    (fn [db [_ path value]]
      (assoc-in db (concat [:anesthesia :current-assessment-canonical] path) value)))

  (rf/reg-event-fx ::fetch-all-assessments
    (fn [_ _]
      {:http-xhrio {:method          :get
                    :uri             "/api/patient/assessments"
                    :response-format (ajax/json-response-format {:keywords? true})
                    :on-success      [::set-all-assessments]
                    :on-failure      [::fetch-all-assessments-failed]}}))
  #+end_src

- **Subscriptions:** Subscriptions provide a reactive way to access data from the app DB. Components subscribe to specific parts of the app DB, and re-frame ensures that these components are re-rendered when the subscribed data changes. Subscriptions are registered using `rf/reg-sub`.

  *Subscribing to data in a component (from `src/cljs/hc/hospital/core.cljs`):*
  #+begin_src clojure
  (let [session-check-pending? @(rf/subscribe [::subs/session-check-pending?])
        is-logged-in? @(rf/subscribe [::subs/is-logged-in])]
    ;; ... use subscribed values
  )
  #+end_src

  *Registering a subscription (from `src/cljs/hc/hospital/subs.cljs`):*
  #+begin_src clojure
  (rf/reg-sub ::current-canonical-assessment
    (fn [db _]
      (get-in db [:anesthesia :current-assessment-canonical])))

  (rf/reg-sub ::filtered-patients
    :<- [::all-patient-assessments]
    :<- [::search-term]
    ;; ... other input signals
    (fn [[api-assessments search-term] _]
      ;; ... logic to filter patients
      ))
  #+end_src

This combination of Reagent for component definition, Ant Design for UI widgets and form handling, and re-frame for state management provides a structured approach to building the application's frontend.
