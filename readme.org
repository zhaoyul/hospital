#+TITLE: 门诊手术麻醉系统项目文档
#+LANGUAGE: zh
#+OPTIONS: toc:nil num:nil

* 项目简介
~hospital~ 是一个使用 Kit 框架构建的 Web 应用程序.旨在为医院提供麻醉前评估等功能.项目包含患者端问卷填写,医生端数据查看与编辑,以及后台管理等模块.

* 先决条件
在开始之前, 请确保你已经安装了以下软件:
- Java Development Kit (JDK) 11 或更高版本 (推荐 OpenJDK)
- Clojure CLI 工具
- Node.js 和 Yarn (或 npm) (用于 ClojureScript 部分)

* 快速开始
** 1. 克隆仓库 (如果需要)
   #+BEGIN_SRC bash
   git clone <your-repository-url>
   cd hospital
   #+END_SRC

** 2. 安装依赖
   - Clojure 依赖 (自动处理):
     Clojure CLI 会根据 =deps.edn= 自动下载依赖.
   - Javascript 依赖:
     #+BEGIN_SRC bash
     yarn install # 或者 npm install
     #+END_SRC

** 3. 启动开发环境
   - *启动 Clojure REPL (后端)*:
     打开一个新的终端.运行以下命令之一:
     #+BEGIN_SRC bash
     # 通用开发 REPL
     clj -M:dev

     # 或者使用 nREPL (适用于 Calva, Cursive 或终端)
     clj -M:dev:nrepl
     # 或者 make repl

     # 或者使用 CIDER nREPL (适用于 Emacs CIDER)
     clj -M:dev:cider
     #+END_SRC
     推荐在 Emacs 中使用 CIDER 连接.
   - *启动 ClojureScript 编译器 (前端)*:
     打开另一个新的终端.运行:
     #+BEGIN_SRC bash
     # 编译并监听医生管理端应用
     npx shadow-cljs watch app

     # 编译并监听患者问卷应用
     npx shadow-cljs watch patient-app
     #+END_SRC
     这将以监听模式编译 ClojureScript 代码.确保两个前端应用都已启动监听.

** 4. 启动应用程序
   在 Clojure REPL 中运行:
   #+BEGIN_SRC clojure
   (go)
   #+END_SRC

** 5. 访问应用
   - 医生管理端 (后台): [[http://localhost:3000]]
   - 患者问卷填写页面: [[http://localhost:3000/patient/fill]]
   - API 健康检查: [[http://localhost:3000/api/health]]

* 开发工作流
  在 Clojure REPL 中使用:
  #+BEGIN_SRC clojure
  (go)    ; 启动系统
  (reset) ; 应用代码更改后重新加载系统
  (halt)  ; 停止系统
  #+END_SRC

  连接 ClojureScript REPL:
  - 启动 ClojureScript 编译器后 (例如 =npx shadow-cljs watch app=),
    连接到 7002 端口的 nREPL.
  - 在 CLJS REPL 中运行 =(shadow.cljs.devtools.api/repl :app)= (或 =:patient-app=) 连接到浏览器.
  - 测试连接: =(js/alert "Hello from CLJS!")=

* 项目结构
  #+BEGIN_EXAMPLE
  hospital
  ├── Dockerfile             # 用于构建 Docker 镜像
  ├── Makefile               # 常用开发命令快捷方式
  ├── README.md              # (英文) 简要说明
  ├── bb.edn                 # Babashka 任务配置
  ├── build.clj              # Clojure Tools Build 构建脚本
  ├── deps.edn               # Clojure 项目依赖和配置
  ├── docs                   # 文档目录
  │   ├── questionnaire.html # 问卷静态原型
  │   ├── requirment.md      # 需求文档
  │   └── 术前评估表.md      # 评估表字段定义
  ├── env                    # 环境特定配置
  │   ├── dev                # 开发环境
  │   │   ├── clj
  │   │   │   ├── hc/hospital # 开发环境特定 Clojure 代码
  │   │   │   └── user.clj    # REPL 辅助函数
  │   │   └── resources       # 开发环境特定资源 (如 logback.xml)
  │   ├── prod               # 生产环境
  │   └── test               # 测试环境
  ├── kit.edn                # Kit 框架模块配置
  ├── package.json           # Node.js 依赖 (用于 CLJS)
  ├── readme.org             # 本文件
  ├── resources              # 应用资源
  │   ├── html               # Selmer HTML 模板 (后端渲染和前端 CLJS 挂载点)
  │   │   ├── home.html      # 医生管理端挂载点
  │   │   └── patient_form.html # 患者问卷挂载点
  │   ├── migrations         #数据库迁移脚本
  │   │   ├── ...-add-patient-assessments-table.up.sql
  │   │   └── ...-add-doctors-table.up.sql
  │   ├── public             # 静态文件 (CSS, JS, 图片)
  │   │   ├── css/screen.css # 主要的 CSS 文件
  │   │   └── js/            # ClojureScript 编译输出目录 (通过 shadow-cljs 配置)
  │   ├── sql                # SQL 查询 (HugSQL)
  │   │   └── queries.sql
  │   └── system.edn         # Integrant 系统配置 (核心)
  ├── shadow-cljs.edn        # Shadow-cljs 编译器配置
  ├── src                    # 源代码
  │   ├── clj                # Clojure 源代码 (后端)
  │   │   └── hc/hospital
  │   │       ├── config.clj # 配置加载
  │   │       ├── core.clj   # 应用入口 (启动/停止)
  │   │       ├── db         # 数据库交互逻辑 (如 doctor.clj)
  │   │       └── web        # Web 相关代码
  │   │           ├── controllers # 控制器 (业务逻辑处理: doctor_api, patient, patient_api)
  │   │           ├── handler.clj # Ring/Reitit 处理程序设置
  │   │           ├── middleware  # 中间件 (auth, core, exception, formats)
  │   │           ├── pages       # 页面布局 (Selmer)
  │   │           └── routes      # 路由定义 (Reitit: api, doctor_api, pages, patient_api, patient_pages)
  │   └── cljs               # ClojureScript 源代码 (前端)
  │       └── hc/hospital
  │           ├── components # Reagent/Ant Design 组件封装 (antd.cljs, form_components.cljs)
  │           ├── core.cljs  # 医生管理端 (app) CLJS 应用入口
  │           ├── db.cljs    # 医生管理端 re-frame 应用数据库 schema
  │           ├── events.cljs# 医生管理端 re-frame 事件处理器
  │           ├── pages      # 医生管理端页面视图组件 (anesthesia_home.cljs)
  │           ├── patient    # 患者问卷 (patient-app) 相关 CLJS 代码
  │           │   ├── core.cljs  # 患者问卷应用入口
  │           │   ├── db.cljs    # 患者问卷 re-frame 数据库
  │           │   ├── events.cljs# 患者问卷 re-frame 事件
  │           │   ├── subs.cljs  # 患者问卷 re-frame 订阅
  │           │   └── views.cljs # 患者问卷 re-frame 视图
  │           ├── subs.cljs   # 医生管理端 re-frame 订阅
  │           └── utils.cljs  # 前端通用工具函数
  ├── test                   # 测试代码
  └── yarn.lock              # Yarn 锁定文件
  #+END_EXAMPLE

* 配置
** 核心配置文件
   - =resources/system.edn=: Integrant 系统定义.包括服务器,数据库连接,路由等.通过 Aero 读取配置.
   - =deps.edn=: Clojure 项目依赖和别名.
   - =shadow-cljs.edn=: ClojureScript 构建配置.定义了两个构建目标:
     - =:app=: 医生管理端应用.输出到 =target/classes/cljsbuild/public/js/app.js=.
     - =:patient-app=: 患者问卷应用.输出到 =target/classes/cljsbuild/public/js/patient/patient-app.js=.
   - =build.clj=: Uberjar 构建脚本.包含 ClojureScript 的生产构建.

** 环境变量
   配置文件可以使用 =#env= 标签读取环境变量.重要环境变量包括:
   - =PORT=: HTTP 服务器端口 (默认 3000).
   - =COOKIE_SECRET~=: 会话 Cookie 的密钥.*生产环境中必须更改此值!*
   - =JDBC_URL~=: 生产数据库的连接 URL (开发/测试环境使用 SQLite 文件).

** 环境特定配置
   - =env/dev= 和 =env/prod= 目录包含特定于环境的配置和代码, 例如 =env.clj= 和 =logback.xml=.
   - 开发环境 REPL 辅助函数位于 =env/dev/clj/user.clj=.

* 模块与功能
** 后端 (Clojure - src/clj/hc/hospital)
- *Web 服务器*: Undertow.通过 =kit.edge.server.undertow= 模块集成.
- *路由*: Reitit.定义在 =web/routes/*= 下.
  - =web/routes/api.clj=: 通用 API 路由 (如健康检查).
  - =web/routes/pages.clj=: 后端渲染的页面路由 (医生管理端主页).
  - =web/routes/patient_pages.clj=: 患者问卷表单页面路由 (=/patient/fill=).
  - =web/routes/patient_api.clj=: 患者问卷提交相关 API.
  - =web/routes/doctor_api.clj=: 医生用户认证和管理 API.
- *API 控制器*: 位于 =web/controllers/*=.
  - =health.clj=: 健康检查.
  - =patient.clj=: 渲染患者问卷页面.
  - =patient_api.clj=: 处理患者问卷提交.姓名转拼音 (使用 HanLP).
  - =doctor_api.clj=: 处理医生注册,登录,登出,信息获取,修改,删除等.
- *数据库交互*:
  - Conman 和 HugSQL: SQL 查询定义在 =resources/sql/queries.sql=.
  - Migratus: 数据库迁移脚本在 =resources/migrations/*=.
  - 开发/测试使用 SQLite.生产环境通过 =JDBC_URL= 连接.
- *认证*: Buddy Auth.用于医生端 API 认证.配置在 =web/middleware/auth.clj=.
- *HTML 模板*: Selmer.模板位于 =resources/html/*=.
- *中间件*: 位于 =web/middleware/*=.包括基础设置,异常处理,数据格式化,认证等.

** 前端 (ClojureScript - src/cljs/hc/hospital)
- *医生管理端 (app)*:
  - 入口: =core.cljs=, 挂载到 =resources/html/home.html= 的 =#app= 元素.
  - UI 框架: Reagent 和 Re-frame.
  - 状态管理: Re-frame (db, events, subs).
  - 主要页面: =pages/anesthesia_home.cljs=.包含患者列表,评估表单等.
  - UI 组件库: Ant Design, 封装在 =components/antd.cljs=.自定义表单组件在 =components/form_components.cljs=.
- *患者问卷端 (patient-app)*:
  - 入口: =patient/core.cljs=, 挂载到 =resources/html/patient_form.html= 的 =#patient-app= 元素.
  - UI 框架: Reagent 和 Re-frame.
  - 状态管理: Re-frame (patient/db, patient/events, patient/subs).
  - 主要视图: =patient/views.cljs=.实现多步骤问卷表单.
  - 样式: 主要依赖 Tailwind CSS (通过 CDN 引入) 及 =resources/html/patient_form.html= 内的内联样式.
- *构建工具*: Shadow-cljs.

** 数据库
- 开发/测试: SQLite (例如 =hospital_dev.db=, =hospital_test.db=).
- 生产: 通过 =JDBC_URL= 环境变量配置.预期为兼容 JDBC 的数据库 (如 PostgreSQL).
- 表结构:
  - =patient_assessments=: 存储患者评估数据.包括 =patient_id=, =assessment_data (JSON)=, =patient_name_pinyin=, =patient_name_initial= 等.
  - =doctors=: 存储医生信息.包括 =username=, =password_hash=, =name= 等.
- 迁移: Migratus 管理.启动时自动运行迁移 (见 =system.edn= 中 =:migrate-on-init? true=).

据流程
** 1. 患者填写问卷
- 用户访问 =/patient/fill= 页面.
- =hc.hospital.web.controllers.patient/patient-form-page= 渲染 =patient_form.html=.
- =patient_form.html= 加载 =/js/patient/patient-app.js= (由 =hc.hospital.patient.core.cljs= 编译).
- 用户在前端填写表单 (多步骤.Re-frame 管理状态).
- 提交时.前端 Re-frame 事件 (如 =::events/validate-and-submit=) 触发.
- 表单数据通过 AJAX POST 请求发送到 =/api/patient/assessment=.
- 后端 =hc.hospital.web.controllers.patient-api/submit-assessment!= 处理请求:
  - 解析 JSON 数据.
  - 使用 HanLP 将患者姓名转换为拼音和首字母.
  - 根据 =patient_id= 判断是插入新记录还是更新现有记录.
  - 通过 HugSQL (方法如 =:insert-patient-assessment!= 或 =:update-patient-assessment!=) 将数据存入 =patient_assessments= 表.
  - 返回成功或失败响应.

** 2. 医生登录与查看/编辑患者数据 (医生管理端)
- 用户访问 =/= (根路径).
- =hc.hospital.web.routes.pages/home= 渲染 =home.html=.
- =home.html= 加载 =/js/app.js= (由 =hc.hospital.core.cljs= 编译).
- *登录*:
  - 医生在前端输入用户名密码.
  - 前端通过 AJAX POST 请求到 =/api/doctors/login=.
  - 后端 =hc.hospital.web.controllers.doctor-api/login-doctor!= 处理:
    - 验证凭据 (与 =doctors= 表中的 =password_hash= 比较).
    - 成功则在 session 中存入医生信息 (如 =:identity=).
- *查看患者列表*:
  - 前端 (例如 =anesthesia_home.cljs=) 通过 Re-frame 事件 (如 =::events/fetch-all-assessments=) 触发.
  - AJAX GET 请求到 =/api/patient/assessments=.
  - 后端 =hc.hospital.web.controllers.patient-api/get-all-patient-assessments-handler= 处理:
    - 可选地根据姓名拼音,首字母,日期等参数进行过滤.
    - 通过 HugSQL (方法如 =:get-all-patient-assessments=) 从 =patient_assessments= 表查询数据.
    - 返回患者列表数据.
  - 前端展示列表.并允许医生选择特定患者.
- *查看/编辑单个患者评估*:
  - 选择患者后.前端 Re-frame 事件 (如 =::events/select-patient=) 更新当前选定患者.
  - 评估数据 (从 =assessment_data= JSON 字段解析) 填充到 Ant Design 表单中.
  - 医生编辑表单内容.Re-frame 事件 (如 =::events/update-brief-medical-history=) 更新前端状态.
  - *保存/更新评估*: (当前保存逻辑可能在患者选择时自动合并或需要显式保存按钮触发)
    - 若需显式保存.则前端 AJAX PUT 请求到 =/api/patient/assessment/:patient-id=.
    - 后端 =hc.hospital.web.controllers.patient-api/update-assessment-by-patient-id!= 处理:
      - 更新 =patient_assessments= 表中对应记录的 =assessment_data=.
- *其他医生操作*:
  - 注册,登出,修改密码等通过 =/api/doctors/*= 相关端点处理.

** 3. HIS 系统集成 (需求提及.当前未实现)
- 需求文档 (=docs/requirment.md=) 提及 HIS 系统接口导入患者数据.并与扫码填<x_bin_118>患者匹配.这是未来的一个数据来源.

* 编译与测试

** 1. 安装 Javascript 依赖
   如果尚未安装，请运行：
   #+BEGIN_SRC bash
   yarn install # 或者 npm install
   #+END_SRC
   此步骤会安装 `package.json` 中定义的依赖，包括 `shadow-cljs`。

** 2. 编译 ClojureScript (前端)
   执行以下命令来编译两个前端应用：
   #+BEGIN_SRC bash
   # 编译医生管理端应用
   npx shadow-cljs release app

   # 编译患者问卷应用
   npx shadow-cljs release patient-app
   #+END_SRC
   编译成功后，相关的 Javascript 文件会输出到 `target/classes/cljsbuild/public/js/` 目录下。这些是生产环境构建。

** 3. 运行 Clojure 测试 (后端)
   执行以下命令来运行后端的测试套件：
   #+BEGIN_SRC bash
   clj -M:test
   # 或者
   make test
   #+END_SRC
   - 测试使用了 `clojure.test`。
   - 测试辅助函数位于 `test/clj/hc/hospital/test_utils.clj`。
   - 测试默认使用 `:test` profile。

   *重要提示:* 当前 Clojure 测试套件存在一些已知问题，导致测试无法全部通过。在执行测试时请注意以下几点：
   - *`hc.hospital.core-test`*: 包含一个简单的断言失败 (`expected: 1, actual: 2`)。
   - *`hc.hospital.web.controllers.doctor-api-test`*:
     - 医生登出 API 未能正确设置 Cookie 以使其立即失效。
     - 在测试某个 API 端点时，发生了 JSON 解析错误 (`java.lang.ClassCastException`)。
   - *`hc.hospital.specs.assessment-complete-cn-spec-test`*: 此测试套件中的15个测试用例因 `:test-chuck-not-available` 错误而失败。这表明 `test.chuck` 库（用于 Malli Schema 的生成式测试）在测试环境中可能未正确配置或不可用。

   建议在进一步开发或部署前调查并解决这些测试问题，以确保后端代码的稳定性和正确性。

* 构建和部署
** 构建 Uberjar (独立 Jar 包)
   #+BEGIN_SRC bash
   clj -T:build all
   # 或者
   make uberjar
   #+END_SRC
   生成 =target/hospital-standalone.jar=.此过程也会触发 ClojureScript 的生产构建 (通过 =build.clj= 中的 =build-cljs= 函数调用 =npx shadow-cljs release app= 和 =npx shadow-cljs release patient-app=).

** 运行 Uberjar
   #+BEGIN_SRC bash
   # 设置生产环境所需的环境变量
   export JDBC_URL="<your_production_database_url>"
   export COOKIE_SECRET="<your_strong_production_secret>"
   export PORT=8080 # (可选)
   java -jar target/hospital-standalone.jar
   #+END_SRC

** Docker
项目包含一个 =Dockerfile=, 用于构建 Docker 镜像进行容器化部署.
#+BEGIN_SRC dockerfile
# syntax = docker/dockerfile:1.2
FROM clojure:openjdk-17 AS build

WORKDIR /
COPY . /

RUN clj -Sforce -T:build all

FROM azul/zulu-openjdk-alpine:17

COPY --from=build /target/hospital-standalone.jar /hospital/hospital-standalone.jar

EXPOSE $PORT

ENTRYPOINT exec java $JAVA_OPTS -jar /hospital/hospital-standalone.jar
#+END_SRC

* 编辑器设置
** Emacs + CIDER
   为了让 CIDER 正确识别开发和测试的源路径和别名, 在项目根目录创建或确保存在 =.dir-locals.el= 文件, 内容如下:
   #+BEGIN_SRC elisp
   ((clojure-mode . ((cider-preferred-build-tool . clojure-cli)
                     (cider-clojure-cli-aliases . ":dev:test"))))
   #+END_SRC

* 主要技术栈
  - Clojure / ClojureScript
  - Kit Framework
  - Ring / Reitit (路由)
  - Undertow (Web 服务器)
  - Integrant (组件管理)
  - Selmer (HTML 模板 - 后端)
  - Shadow-cljs (CLJS 构建)
  - Reagent / Re-frame (CLJS UI)
  - Ant Design (UI 组件库)
  - HugSQL / Conman / Migratus (SQL 数据库交互)
  - SQLite (开发/测试数据库)
  - Buddy (认证)
  - HanLP (中文处理.用于姓名转拼音)

* TODO / 未来展望 (根据需求文档)
  - [ ] HIS 系统接口导入患者数据.并与扫码填写的患者匹配.
  - [ ] 患者列表支持时间筛选.姓名模糊查找 (部分已通过 API 参数实现.前端 UI 可能需要增强).
  - [ ] 医生端支持删除患者操作.
  - [ ] 医生能够看到所有患者.患者需要标注所属医生(只有所属医生能够编辑患者内容)-> 权限细化.
  - [ ] 评估表审核流程 (批准,暂缓,驳回状态流转).
  - [ ] 填写知情同意书 (按照模版.医生填写).
  - [ ] 调用医生电子签名 (加到模版里).
  - [ ] 打印预览与打印功能.
  - [ ] 管理后台:医生列表 (院区.科室.账号增删改查.维护电子签名.从 HIS 同步花名册).字典管理.

* 请在migration中增加一个新用户

好的，我们可以在 =resources/migrations= 目录下创建一个新的 SQL 迁移文件来添加一个新用户 (医生)。

首先，你需要为新用户密码生成一个哈希值。你可以在 Clojure REPL 中执行以下操作：
#+begin_src clojure
(require '[buddy.hashers :as hashers])
(hashers/derive "你的密码") ; 将 "你的密码" 替换为你想要的密码
#+end_src
复制输出的哈希字符串。

然后，创建以下迁移文件：

1.  文件名: =resources/migrations/YYYYMMDDHHMMSS-add-default-admin-user.up.sql=
    (请将 =YYYYMMDDHHMMSS= 替换为当前时间戳，确保它在现有迁移之后，例如 =20250507000100=)

    #+begin_src sql
    -- resources/migrations/20250507000100-add-default-admin-user.up.sql
    INSERT INTO doctors (username, password_hash, name, created_at, updated_at)
    VALUES (
        'admin',
        -- 将下面的哈希替换为你用 (hashers/derive "你的密码") 生成的实际哈希值
        '$2a$11$YOUR_GENERATED_PASSWORD_HASH_HERE_REPLACE_ME',
        '默认管理员',
        datetime('now'),
        datetime('now')
    );
    #+end_src


* 打包&部署
- 打包
 #+begin_src shell :results pp :exports both
 clj -Sforce -T:build all
 #+end_src
- 部署
 #+begin_src shell :results pp :exports both
 export JDBC_URL="jdbc:sqlite:hospital.db"
 export PORT="4500"
 /usr/lib/jvm/java-1.21.0-openjdk-amd64/bin/java -jar hospital-standalone.jar
 #+end_src
* gptel
#+begin_src elisp :results silent
  (let* ((prompt-file "code-prompt.md")
         (buffer "*gemini-app-and-server*"))
    (delete-file prompt-file)
    (shell-command "code2prompt . --no-clipboard --output-file code-prompt.md")
    (ignore-errors (gptel-context-remove-all))
    (gptel-add-file prompt-file)
    (when (> (length (window-list)) 1)
      (delete-window (next-window)))
    (gptel buffer)
    (split-window-right)
    (other-window 1)
    (switch-to-buffer buffer ))
#+end_src

* Reagent 与 Ant Design 使用总结

本文档总结了项目中 Reagent 和 Ant Design 的使用方式，重点关注组件渲染、表单管理以及使用 re-frame 进行状态管理。

* 组件渲染：`:>` 和 `:f>`

项目使用 Reagent 的 Hiccup 风格语法来定义 UI 组件。

- **`:>` (渲染 Ant Design 组件 / HTML 元素):** 此语法主要用于渲染 Ant Design 组件。Ant Design 组件从 "antd" 库导入。它同时也是渲染常规 HTML DOM 元素的标准 Hiccup 语法。

  *示例来源 `src/cljs/hc/hospital/components/form_components.cljs` (Ant Design 按钮):*
  #+begin_src clojure
  [:> Button {:type "primary"} "提交"] ;; 渲染一个 Ant Design 的按钮组件
  #+end_src

  *示例来源 `src/cljs/hc/hospital/pages/questionnaire.cljs` (Ant Design 表格):*
  #+begin_src clojure
  [:> Table {:columns questionnaire-columns ;; 表格列的定义
             :dataSource mock-questionnaire-data}] ;; 表格数据源
  #+end_src

- **`:f>` (渲染 Reagent Form-2/Form-3 组件):** 此语法用于渲染定义为 "Form-2" 或 "Form-3" 的 Reagent 组件（即返回渲染函数的函数，或接受参数并返回渲染函数的函数）。这通常用于顶层组件，或者那些通过 `r/atom` 管理自身状态或需要生命周期方法的组件。

  *示例来源 `src/cljs/hc/hospital/core.cljs` (根 Reagent 组件):*
  #+begin_src clojure
  (d/render [:f> app-root] (.getElementById js/document "app")) ;; 使用 :f> 渲染 app-root 根组件
  #+end_src
  虽然项目中的许多组件被定义为简单函数 (Form-1 组件) 并使用标准的 `[:> component-fn]` 或 `[component-fn]` 语法渲染，但 `:f>` 适用于那些需要 Reagent Form-2/3 组件提供的更复杂生命周期或状态管理功能的组件。通常，如果简单 Reagent 组件是返回 Hiccup 的简单函数，它们也可能用 `:>` 来调用。

* 使用 Ant Design 管理表单

Ant Design 的 Form 组件 (`antd/Form`) 是创建和管理表单的主要工具。

- **`Form.useForm`:** 这个钩子用于创建一个表单实例，该实例提供控制表单的方法，例如获取或设置字段值、校验字段和重置表单。

  *示例来源 `src/cljs/hc/hospital/components/form_components.cljs` (`standard-form` 组件内部):*
  #+begin_src clojure
  (defn standard-form [{:keys [form-data subscription-key update-event form-content]}]
    (let [data @(rf/subscribe [subscription-key]) ;; 从 re-frame 订阅获取表单初始值
          [form] ((.-useForm (.-Form js/antd)))] ; <--- 调用 Form.useForm 钩子获取表单实例
      [:> Form {:form form ;; 将表单实例传递给 Form 组件
                :layout "vertical" ;; 设置布局为垂直
                :initialValues data ;; 设置表单初始值
                :onValuesChange (fn [_changed-values all-values] ;; 表单值改变时的回调
                                  (rf/dispatch [update-event all-values])) ;; 派发 re-frame 事件更新状态
                :style {:paddingBottom "24px"}}
       form-content])) ;; 渲染表单内容
  #+end_src
  这里，`((.-useForm (.-Form js/antd)))` 调用了 `useForm` 钩子，`form` 成为了表单实例。然后这个实例被传递给 Ant Design `Form` 组件的 `:form` 属性。

- **响应表单变化 (`:onValuesChange` 和 `Form.useWatch`):**
  - **`:onValuesChange`**: 本项目主要使用 `Form` 组件的 `:onValuesChange` 属性来响应任何表单字段的变化。当一个值改变时，`:onValuesChange` 回调被触发，然后派发一个 re-frame 事件来更新应用状态。

    *示例来源 `src/cljs/hc/hospital/components/form_components.cljs` (`standard-form` 组件内部):*
    #+begin_src clojure
    [:> Form {;; ... 其他属性
              :onValuesChange (fn [_changed-values all-values] ;; 当表单内任意字段值改变时
                                (rf/dispatch [update-event all-values])) ;; 派发事件，携带所有值
              ;; ...
              }]
    #+end_src
    这种方法将表单状态管理集中在 re-frame 的 app DB 中，而不是通过 `Form.useWatch` 使用组件局部状态。

  - **`Form.useWatch`**: 虽然本项目未使用 `Form.useWatch`，但它可以用于在组件内部观察特定字段的变化，而无需立即更新全局状态。例如，可以直接在组件的渲染逻辑中根据一个字段的值有条件地禁用另一个字段。

  - **`:dependencies`**: 在 `checkbox-with-conditional-input` 组件中，使用了 `:dependencies` 属性来声明字段间的依赖关系，这与 `Form.useWatch` 的目的一些情况下是类似的，用于根据依赖字段的值动态改变当前字段的行为或外观。

    *示例来源 `src/cljs/hc/hospital/components/form_components.cljs` (部分相关代码):*
    #+begin_src clojure
    [:> Form.Item {:name field-name
                   :noStyle true
                   :dependencies [(keyword (str field-name "-checkbox"))]} ;; 声明依赖于同名前缀的 checkbox
     ;; fixme (原注释，表示此部分待修复或实现)
     #_(fn [form-instance] ;; 这是一个函数作为子元素，用于动态渲染
         (let [checked? (.getFieldValue form-instance (keyword (str field-name "-checkbox")))] ;; 获取依赖 checkbox 的值
           [:> Input {:placeholder "请输入"
                      :disabled (not checked?) ;; 根据 checkbox 是否选中来禁用输入框
                      :style {:width (or input-width "100%")}}]))]
    #+end_src
    这段被注释掉的代码展示了如何使用表单实例 (`form-instance`) 来获取一个字段的值，并动态地改变 UI。在更复杂的场景下，`Form.useWatch` 可以作为这种模式的替代方案。

* 使用 re-frame 进行状态管理

`re-frame` 用于管理应用程序的状态。

- **App DB (应用数据库):** 应用程序的状态存储在一个单一的、全局的 atom 中，称为 "app DB"。这个数据库的初始结构在 `src/cljs/hc/hospital/db.cljs` 中定义。

  *示例来源 `src/cljs/hc/hospital/db.cljs` (`default-db`):*
  #+begin_src clojure
  (def default-db
    { ;; 整个默认数据库状态的根 Map
     :anesthesia ;; 麻醉模块状态
     {:active-tab "patients" ;; 当前选中的主标签页
      :all-patient-assessments [] ;; 所有患者评估列表
      :current-patient-id nil ;; 当前选中的患者ID
      ;; ... 更多麻醉相关状态
      }
     :doctors [] ;; 医生列表
     :current-doctor nil ;; 当前登录的医生信息
     :is-logged-in false ;; 是否已登录
     ;; ... 更多全局状态
     })
  #+end_src

- **Events (事件):** 事件是描述应用中发生的事情的消息（例如，用户交互、服务器响应）。事件被派发 (dispatch) 以更新 app DB。事件处理器使用 `rf/reg-event-db` (用于对 app DB 的同步更改) 或 `rf/reg-event-fx` (用于带有副作用的事件，如 HTTP 请求) 来注册。

  *派发事件 (来源 `src/cljs/hc/hospital/components/form_components.cljs`):*
  #+begin_src clojure
  (rf/dispatch [update-event all-values]) ;; 派发事件，事件类型为 update-event，参数为 all-values
  #+end_src

  *注册事件处理器 (来源 `src/cljs/hc/hospital/events.cljs`):*
  #+begin_src clojure
  ;;注册一个处理数据库更新的事件
  (rf/reg-event-db ::update-canonical-assessment-field
    (fn [db [_ path value]] ;; db 是当前的 app DB，[_ path value] 是事件向量解构
      (assoc-in db (concat [:anesthesia :current-assessment-canonical] path) value))) ;; 更新 db 中指定路径的值

  ;; 注册一个处理副作用（HTTP请求）的事件
  (rf/reg-event-fx ::fetch-all-assessments
    (fn [_ _] ;; 不需要 app DB 或事件参数
      {:http-xhrio {:method          :get ;; HTTP GET 请求
                    :uri             "/api/patient/assessments" ;; 请求地址
                    :response-format (ajax/json-response-format {:keywords? true}) ;; 期望 JSON 响应并转为关键字
                    :on-success      [::set-all-assessments] ;; 成功时派发的事件
                    :on-failure      [::fetch-all-assessments-failed]}})) ;; 失败时派发的事件
  #+end_src

- **Subscriptions (订阅):** 订阅提供了一种从 app DB 响应式地访问数据的方式。组件订阅 app DB 的特定部分，当订阅的数据发生变化时，re-frame 会确保这些组件重新渲染。订阅使用 `rf/reg-sub` 注册。

  *在组件中订阅数据 (来源 `src/cljs/hc/hospital/core.cljs`):*
  #+begin_src clojure
  (let [session-check-pending? @(rf/subscribe [::subs/session-check-pending?]) ;; 订阅会话检查是否挂起的状态
        is-logged-in? @(rf/subscribe [::subs/is-logged-in])] ;; 订阅用户是否已登录的状态
    ;; ... 使用订阅到的值
  )
  #+end_src

  *注册订阅 (来源 `src/cljs/hc/hospital/subs.cljs`):*
  #+begin_src clojure
  ;; 注册一个简单的订阅，直接从 db 中获取数据
  (rf/reg-sub ::current-canonical-assessment
    (fn [db _] ;; db 是 app DB，第二个参数是查询向量（此处未使用）
      (get-in db [:anesthesia :current-assessment-canonical]))) ;; 返回当前规范化评估数据

  ;; 注册一个带有输入信号（其他订阅）的计算订阅
  (rf/reg-sub ::filtered-patients
    :<- [::all-patient-assessments] ;; 输入信号1：所有患者评估
    :<- [::search-term] ;; 输入信号2：搜索词
    ;; ... 其他可能的输入信号
    (fn [[api-assessments search-term] _] ;; 解构输入信号的值
      ;; ... 根据输入信号计算并返回派生数据（过滤后的患者列表）
      ))
  #+end_src

Reagent 用于组件定义，Ant Design 用于 UI 小部件和表单处理，re-frame 用于状态管理，这种组合为构建应用程序的前端提供了一种结构化的方法。
